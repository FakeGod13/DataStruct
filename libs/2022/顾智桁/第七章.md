# 第七章

## 图

### 结构定义

图G是由两个集合V和R组成，其中V是顶点的有穷非空集合，R是V中顶点偶对的有穷集合--Graph = (V, R)；

有向图：<v,w>表示从 v 到 w 的一条弧，并称 v 为弧尾，w 为弧头。

无向图：若<v, w>VR 必有<w, v>VR, 则称 (v,w) 为顶点v 和顶点 w 之间存在一条边。

顶点的度：和顶点v关联的边的数目定义为顶点的度

### 图的基本操作

#### 图的建立和销毁

`CreatGraph(&G, V, VR)`

`DestoryGraph(&G)`

#### 图的遍历

`DFSTraverse(G, v)`深度优先遍历图G

`BFSTraverse(G, v)`广度优先遍历图G

#### 对顶点的操作

`LocateVex(G, u)`

`GetVex(G, v)`

`PutVex(&G, v, value)`

`InsertVex(&G, v)`

`DeleteVex(&G, v)`

#### 对邻接点的操作

`FirstAdjVex(G, v)`

`NextAdjVex(G, v, w)`

#### 对图中弧的操作

`InsertArc(&G, v, w)`

`DeleteArc(&G, v, w)`

### 图的存储

#### 图的邻接矩阵

图的邻接矩阵是表示顶点之间相邻关系的矩阵。设G(V,VR)是具有n个顶点的图，用邻接矩阵表示法表示图，除了用二维数组存储图中各顶点间的关系VR外，还需要用一维数组存储图中的顶点V。

#### 图的邻接表

图的链式存储结构。在邻接表中，对图中每个顶点vi建立一个单链表，把与vi相邻接的顶点放在这个链表中。邻接表中每个单链表的第一个结点存放有关顶点的信息，把这一结点看成链表的表头，其余结点存放有关边的信息。对于图中每条弧均依附于两个结点，因此链表中的结点就是具有相同弧尾的弧结点。在实际存储时，图中顶点的邻接点链成链表，表结点中存储邻接点的存储位置。而在存储图中顶点时，除了本身的数据信息外，还要存储指示其第一个邻接点的指针

#### 邻接表的优缺点

##### 优点

1. 便于增加和删除顶点。
2. 便于统计边的数目，按顶点表顺序扫描所有边表可得到边的数目，时间复杂度为$O(n+e)$。
3. 空间效率高，空间复杂度为$O(n+e)$。适合表示稀疏图。

##### 缺点

1. 不便于判断顶点之间是否有边，要判定$vi$和$vj$之间是否有边，就需要扫描第$i$个边表，最坏情况下要耗费$O(n)$时间。
2. 不便于计算有向图各个顶点的度。

####  有向图的十字链表

##### 弧的结点结构

弧尾顶点位置 + 弧头顶点位置 + 指向下一个有相同弧尾的弧结点 + 指向下一个有相同弧头的弧结点

##### 顶点的结点结构

顶点信息 + 指向该顶点的第一条入弧 + 指向该顶点的第一条出弧

#### 无向图的邻接多重表

##### 边的结点结构

边顶点位置 + 边顶点2位置 + 指向下一个依附顶点1的边结点 + 指向下一个依附顶点2的边结点

##### 顶点的结点结构

顶点信息 + 指向依附该顶点的第一条边

### 图的遍历

#### 图的遍历策略

从图中某个顶点出发遍历图，访遍图中其余顶点，并且使图中的每个顶点仅被访问一次的过程。

#### 深度优先搜索

从图中某个顶点v出发，访问v（画实线圈做标记），若v的邻接点有多个，确定一个未被访问的邻接点w，访问w（画实线圈），然后再按同样方法访问w的未被访问的邻接点（画实线圈），以此类推，画出搜索树中实线圈结点。对于在遍历过程中某顶点已访问过的邻接点来说，在树中用虚线圈标记，接着，退回一步，退到前一次刚访问过的顶点，看是否还有其它没有被访问的邻接点。如果有，则访问此顶点，之后再从此顶点出发，进行与前述类似的访问；如果没有，就再退回一步进行搜索。重复上述过程，直到连通图中所有顶点都被访问过为止。

#### 广度优先搜索

从图中某顶点出发，访问此顶点之后依次访问其各个未被访问的邻接点，然后从这些邻接点出发依次访问它们的邻接点，并使“先被访问的顶点的邻接点”要先于“后被访问的顶点的邻接点”被访问，直至所有已被访问的顶点的邻接点都被访问。若图中尚有顶点未被访问，则另选图中未被访问的顶点作为起始点，重复以上过程，直到图中所有顶点都被访问为止。
