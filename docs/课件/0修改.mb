 VSCode# 绪论

## 为什么要学数据结构？

- 数据结构是计算机科学的重要基础课程之一
- 数据结构是计算机考研必考科目
  - 全国计算机统考标准408包括：数据结构、计算机组成原理、计算机网络、操作系统
  - 工大计算机考研标准808只考数据结构
- 数据结构是算法竞赛考察的进阶内容

## 数据结构是什么？

**程序 = 数据结构 + 算法。**

**数据结构 = 数据 + 结构。**

完全无法理解这个答案？没有关系。
本门课程将由这两个公式开始，也由这个两个公式结束。
你所需要做的是带着对这个问题疑问，在后面的章节不断探索，最终理解这一概念。

解释抽象概念有两种方法，一种是高度凝练，另一种是巨细无遗。
我们在绪论中首先给出前者，在绪论外的章节实践后者。

## 算法分析

**程序 = 数据结构 + 算法。**
数据结构和算法是密不可分的，在研究这两者时有是先设计出了数据结构再找到了它的算法应用，有时是先设计了算法再为算法寻找需要的数据结构。
因此在学习数据结构的时候，我们不能把它剥离出来单独理解，而是必须配合着算法一同学习。
而从算法分析入手就是一个较好的选择。

### 算法复杂度

评级一个人可以从多个角度入手，他的成就，个人事迹，他人对他的评价等等。
评价一个算法同样如此，而其中一个最重要的角度是算法复杂度。
算法复杂度包括时间复杂度和空间复杂度，这两者绝大多数情况下是鱼与熊掌的关系。
所谓算法分析也就是去思考什么时候该吃鱼，什么时候该吃熊掌。

#### 时间复杂度

算法用时随数据规模而增长的趋势，即**时间复杂度**。

##### 大 $O$ 表示法

![Big-O](images/Big-O.png)

假设算法的问题规模为n，那么输入的数据规模可以用函数 $f(n)$ 来表示。

随着数据规模n的增大，算法执行时间的增长率和 $f(n)$ 的增长率相同，这称作为算法的渐近时间复杂度，简称时间复杂度，记为 $O(f(n))$。

算法导论给出的解释：大 $O$ 用来表示上界的，当用它作为算法的最坏情况运行时间的上界，就是对任意数据输入的运行时间的上界。

>此小节侧重实用性，不作严谨的说明。
>详细内容可参考[OI-Wiki](https://oi-wiki.org/basic/complexity/)上的讲解

##### 常数级
时间复杂度为常数
例如:
```c
#include<stdio.h>
int main()
{
  int a,n;
  for(a=1;a<=5;a++)
  n++;
  return 0;
}
```
##### 线性级
O(n)—线性阶，就代表数据量增大几倍，耗时也增大几倍
例如：
```c
#include<stdio.h>
int main()
{
  int i,n,sum;
  scanf("%d",&n);
  for(i=0;i<=n;i++)
  {
    sum+=n;
  }
  printf("%d",sum);
  return 0;
}
```
##### 对数级
 O (logn)，当数据增大 n 倍时，耗时增大 logn 倍
例如：
对分查找
```c
- (int)BinarySearch:(NSArray *)originArray element:(int)element
{
    int low, mid, high;
    low = 0; high = (int)originArray.count - 1;
    while (low <= high) {
        mid = (low + high) / 2;
        if ([originArray[mid] intValue] < element) {
            low = mid + 1;
        } else if ([originArray[mid] intValue] > element) {
            high = mid -1;
        } else {
            return mid;
        }
    }
    
    return -1;
}
```
##### 幂级
O(n^2^)，就代表数据量增大n倍时，耗时增大n的平方倍
例如：冒泡排序，选择排序
```c
#include <stdio.h>
 
#define SIZE 10
int main()
{
    int a[SIZE]={12 ,43,9,13,67,98,101,89,3,35};//十个数的无序数列
    int i,j,t;
    printf("此程序使用冒泡排序法排列无序数列！\n");
    //冒泡排序
    for(i=0;i<10-1;i++)//n个数的数列总共扫描n-1次
    {
        for(j=0;j<10-i-1;j++)//每一趟扫描到a[n-i-2]与a[n-i-1]比较为止结束
        {
            if(a[j]>a[j+1])//后一位数比前一位数小的话，就交换两个数的位置（升序）
            {
               t=a[j+1];
               a[j+1]=a[j];
               a[j]=t;
            }
        }
    }
 
    printf("排列好的数列是：\n");
    //输出排列好得吃数列
    for(i=0;i<10;i++)
    {
 
        printf("%d ",a[i]);
    }
    return 0;
}
```
##### 指数级
就代表数据量增大n倍时，耗时增大2^n^的平方倍
例如：
递归求解斐波那契数列
```c
#include<stdio.h>

//函数定义
int fib(int m)
{
//前两项为 1  1 
    if(m==1 || m==2)
        return 1;
//第i项为i-1项与i-2项之和
    else
        return  fib(m-1)+fib(m-2) ;
}

int main()
{
    int n,  i;
    printf("请输入项数：\n");
    scanf("%d",&n);
    //逐项传入
    for(i=1 ; i<n+1; i++)
    {
        printf("fib(%d)=%-4d   ", i , fib(i) );
    //每五项占一行
        if(i%5==0)
        {
            printf("\n");
        }
    }
    
    return 0;
}
```
##### 阶乘级别
就代表数据量增大n倍时，耗时增大n!倍
例如：
阶乘求和
```c
#include<stdio.h>
int main()
{
  int sum,i,n,a=1;
  scanf("%d",$n);
  for(i=1;i<=n;i++)
  {
    a=1;
    for(j=i;i<=i;j++)
    {
      a=a*j;
    }
    sum=sum+j;
  }
  printf("%d",sum);
  return 0;
}
```
#### 空间复杂度
1.输入空间： 存储输入数据所需的空间大小
2.暂存空间： 算法运行过程中，存储所有中间变量和对象等数据所需的空间大小
3.输出空间： 算法运行返回时，存储输出数据所需的空间大小
空间复杂度指在输入数据大小为 N 时，算法运行所使用的「暂存空间」+「输出空间」的总体大小
### 算法优化
通过减小时间复杂度与空间复杂度来优化算法
## 算法思想

### 有哪些算法思想？

枚举/朴素/暴力、模拟、分治和递归、贪心、动态规划、回溯、排序、查找、搜索

### 算法思想与现实生活的联系

## 算法中的数据结构
