# 绪论

## 为什么要学数据结构？

- 数据结构是计算机科学的重要基础课程之一
- 数据结构是计算机考研必考科目
  - 全国计算机统考标准408包括：数据结构、计算机组成原理、计算机网络、操作系统
  - 工大计算机考研标准808只考数据结构
- 数据结构是算法竞赛考察的进阶内容

## 数据结构是什么？

**程序 = 数据结构 + 算法。**

**数据结构 = 数据 + 结构。**

完全无法理解这个答案？没有关系。
本门课程将由这两个公式开始，也由这个两个公式结束。
你所需要做的是带着对这个问题疑问，在后面的章节不断探索，最终理解这一概念。

解释抽象概念有两种方法，一种是高度凝练，另一种是巨细无遗。
我们在绪论中首先给出前者，在绪论外的章节实践后者。

## 算法分析

**程序 = 数据结构 + 算法。**
数据结构和算法是密不可分的，在研究这两者时有是先设计出了数据结构再找到了它的算法应用，有时是先设计了算法再为算法寻找需要的数据结构。
因此在学习数据结构的时候，我们不能把它剥离出来单独理解，而是必须配合着算法一同学习。
而从算法分析入手就是一个较好的选择。

### 算法复杂度

评级一个人可以从多个角度入手，他的成就，个人事迹，他人对他的评价等等。
评价一个算法同样如此，而其中一个最重要的角度是算法复杂度。
算法复杂度包括时间复杂度和空间复杂度，这两者绝大多数情况下是鱼与熊掌的关系。
所谓算法分析也就是去思考什么时候该吃鱼，什么时候该吃熊掌。

#### 时间复杂度

算法用时随数据规模而增长的趋势，即**时间复杂度**。

##### 大 $O$ 表示法

![Big-O](images/Big-O.png)

假设算法的问题规模为n，那么输入的数据规模可以用函数 $f(n)$ 来表示。

随着数据规模n的增大，算法执行时间的增长率和 $f(n)$ 的增长率相同，这称作为算法的渐近时间复杂度，简称时间复杂度，记为 $O(f(n))$。

算法导论给出的解释：大 $O$ 用来表示上界的，当用它作为算法的最坏情况运行时间的上界，就是对任意数据输入的运行时间的上界。

>此小节侧重实用性，不作严谨的说明。
>详细内容可参考[OI-Wiki](https://oi-wiki.org/basic/complexity/)上的讲解



##### 常数级

###### 读取元素：

时间复杂度：$O(1)$



##### 对数级

###### 二分查找：

因为二分查找不会查找数列的全部元素，而查找的数据量其实正好符合元素的对数，正常情况下每次查找的元素都在一半一半地减少。

时间复杂度:  $O(log_2n)$

在一个**有序**序列中查找某个数key:

```c++
int main(){
    int key;
    cin >> key;
    vector<int> v = {1, 4, 5, 6, 7, 9};
    int l = 0, r = v.size() - 1;
    int mid;
    while(l <= r){
        mid = (l + r) / 2;
        if(v[mid] == key){
            cout << "已找到" << endl;
            return 0;
        }
        else if(v[mid] < key)
            l = mid + 1;
        else
            r = mid - 1;
    }
    cout << "未找到" << endl;
    return 0;
}
```



##### 线性级

###### 查找元素：

时间复杂度：$O(n)$

```c++
void print(vector<int> arr){
    for(int i = 0; i < arr.size(); i++)
        cout << arr[i] << endl;
}
```



##### 线性对数级

###### 快速排序：（可以趋近于幂级）

时间复杂度：$O(n log_2n)$

1. 首先在一个序列中找一个数作为基准(key)，一般取第一个，遍历一次数组，使key左边的数均小于key，右边的数大于key；
2. 第一轮后以key为分界点拆分成两个序列，继续递归。

```c++
void quick_sort(vector<int> &nums, int l, int r) { //l = 0, r = nums.size()
    if (l + 1 >= r)
        return;
    int first = l, last = r - 1, key = nums[first]; //取第一个数为基准
    while (first < last){
        while(first < last && nums[last] >= key) {
            --last;
        }
        nums[first] = nums[last]; //找到小于key的数，放在左边
        while (first < last && nums[first] <= key) {
            ++first;
        }
        nums[last] = nums[first]; //大于key的数放右边
    }
    nums[first] = key;
    quick_sort(nums, l, first);
    quick_sort(nums, first + 1, r);
}
```
###### 归并排序：

时间复杂度：$O(n log_2n)$

1. 将序列中待排序数字分为若干组(每个数字为一组)；
2. 将若干个组两两合并，保证合并后的组使有序的；
3. 重复第二步直到只剩一组。

```c++
void merge_sort(vector<int> &nums, int l, int r, vector<int> &temp) {
    if (l + 1 >= r) {
        return;
    }// 递归结束条件，每个数字为单独的一组
    int m = l + (r - l) / 2;
    merge_sort(nums, l, m, temp);
    merge_sort(nums, m, r, temp);
    int p = l, q = m, i = l;
    while (p < m || q < r) {
        if (q >= r || (p < m && nums[p] <= nums[q])) {
            temp[i++] = nums[p++];
        } else {
            temp[i++] = nums[q++];
        }
    }
    for (i = l; i < r; ++i) {
        nums[i] = temp[i];
    }
}
```



##### 幂级

###### 冒泡排序：

时间复杂度：$O(n^{2})$

```c++
void bubble_sort(vector<int> nums)
{
    int temp = 0, i = 0, j = 0;
    for (i = 0; i < nums.size() - 1; i++){
        for (j = 0; j < nums.size() - 1 - i; j++){
            if (nums[j] > nums[j + 1]){
                temp = nums[j];
                nums[j] = nums[j + 1];
                nums[j + 1] = temp;
            }
        }
    }
}
```



##### 指数级

###### 递归求解斐波那契数列:

时间复杂度：$O(2^{n})$

```c++
int fib(int index) {
    // 设置结束递归的条件
    if (index == 1 || index == 2)
        return 1;
    return fib(index - 1) + fib(index - 2);
}
```



##### 阶乘级别

###### 旅行推销员问题：

时间复杂度：$O(n!)$

问题描述: 设有$N$个城市组成的交通图，一个售货员从住地城市出发，到其他城市各次取推销货物，最后回到住地城市。假定任意两个城市$i$, $j$之间的距离$d$是已知的，问应该怎么样选择一条最短的路线。



#### 空间复杂度

###### 桶排序：

空间复杂度：$O(n)$

```c++
void bksort(vector<int> v){ // v中数均小于105
    int hash[105]
    for (int i = 0; i < v.size(); i++) {
        hash[v[i]]++;
    }
    for (int i = 0; i < 105; i++) {
        if (v[i] != 0) {
            for (int j = 1; j <= v[i]; j++) 
                cout << i << ' ';
        }
    }
    return 0;
}
```




### 算法优化

算法优化是指对算法的有关性能进行优化，如时间复杂度、空间复杂度、正确性、健壮性。由于算法应用情景变化很大，算法优化可以使算法具有更好泛化能力。

## 算法思想

### 有哪些算法思想？

枚举/朴素/暴力、模拟、分治和递归、贪心、动态规划、回溯、排序、查找、搜索

### 算法思想与现实生活的联系

## 算法中的数据结构
