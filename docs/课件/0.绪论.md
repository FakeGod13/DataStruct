# 绪论

## 为什么要学数据结构？

- 数据结构是计算机科学的重要基础课程之一
- 数据结构是计算机考研必考科目
  - 全国计算机统考标准408包括：数据结构、计算机组成原理、计算机网络、操作系统
  - 工大计算机考研标准808只考数据结构
- 数据结构是算法竞赛考察的进阶内容

## 数据结构是什么？

**程序 = 数据结构 + 算法。**

**数据结构 = 数据 + 结构。**

完全无法理解这个答案？没有关系。
本门课程将由这两个公式开始，也由这个两个公式结束。
你所需要做的是带着对这个问题疑问，在后面的章节不断探索，最终理解这一概念。

解释抽象概念有两种方法，一种是高度凝练，另一种是巨细无遗。
我们在绪论中首先给出前者，在绪论外的章节实践后者。

## 算法分析

**程序 = 数据结构 + 算法。**
数据结构和算法是密不可分的，在研究这两者时有是先设计出了数据结构再找到了它的算法应用，有时是先设计了算法再为算法寻找需要的数据结构。
因此在学习数据结构的时候，我们不能把它剥离出来单独理解，而是必须配合着算法一同学习。
而从算法分析入手就是一个较好的选择。

### 算法复杂度

评级一个人可以从多个角度入手，他的成就，个人事迹，他人对他的评价等等。
评价一个算法同样如此，而其中一个最重要的角度是算法复杂度。
算法复杂度包括时间复杂度和空间复杂度，这两者绝大多数情况下是鱼与熊掌的关系。
所谓算法分析也就是去思考什么时候该吃鱼，什么时候该吃熊掌。

#### 时间复杂度

算法用时随数据规模而增长的趋势，即**时间复杂度**。

##### 大 $O$ 表示法

![Big-O](images/Big-O.png)

假设算法的问题规模为n，那么输入的数据规模可以用函数 $f(n)$ 来表示。

随着数据规模n的增大，算法执行时间的增长率和 $f(n)$ 的增长率相同，这称作为算法的渐近时间复杂度，简称时间复杂度，记为 $O(f(n))$。

算法导论给出的解释：大 $O$ 用来表示上界的，当用它作为算法的最坏情况运行时间的上界，就是对任意数据输入的运行时间的上界。

>此小节侧重实用性，不作严谨的说明。
>详细内容可参考[OI-Wiki](https://oi-wiki.org/basic/complexity/)上的讲解

##### 常数级
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD

<<<<<<< Updated upstream
=======
...
>>>>>>> fbf0d81439a58342cdb77301705c99d4a989f1ab
=======
...
>>>>>>> fbf0d81439a58342cdb77301705c99d4a989f1ab
=======
...
>>>>>>> fbf0d81439a58342cdb77301705c99d4a989f1ab
##### 线性级
计数排序
基数排序
桶排序
动态规划
等...
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD

##### 对数级
二分查找
```c
int  BinarySearch( List L, int X ){
    int s=1;
    int e=L->Last;
    while(s<e){
    int mid=(s+e)/2;
    if(L->Data[mid]>X){
        e=mid-1;
    }
    if(L->Data[mid]<X){
      s=mid+1;
    }
    if(L->Data[mid]==X){
        return mid;
    }
    }
    return NotFound;
}

=======
##### 对数级
二分查找
>>>>>>> fbf0d81439a58342cdb77301705c99d4a989f1ab
=======
##### 对数级
二分查找
>>>>>>> fbf0d81439a58342cdb77301705c99d4a989f1ab
=======
##### 对数级
二分查找
>>>>>>> fbf0d81439a58342cdb77301705c99d4a989f1ab
快速排序（一般归为对数级，实际上可以取经于幂级）
归并排序
堆排序
等...

归并排序

堆排序
等...
##### 幂级
希尔排序
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD

冒泡排序
```c
void func(int a[],int len){
    for(int i=0;i<len-1;i++){
        for(int j=0;j<len-1;j++){
            if(a[j]>a[j+1]){
                int t=a[j];
                a[j]=a[j+1];
                a[j+1]=t;
            }
        }
    }
}
选择排序
```c
void func(int a[],int len){
    for(int i=0;i<len-1;i++){
        int pos=i;
        for(int j=0;j<len;j++){
            if(a[j]<a[pos]) pos=j;
        }
        int t = a[i];
        a[i] = a[pos];
        a[pos] = t;
    }
}

插入排序
```c
void func(int a[],int len){
    for(int i=1;i<len;i++){
        int t=a[i],j=0;
        for(j=i-1;j>=0&&a[j]>t;j--)
        a[j+1]=a[j];
        a[j+1]=t;
    }
}

=======
冒泡排序
选择排序
插入排序
>>>>>>> fbf0d81439a58342cdb77301705c99d4a989f1ab
=======
冒泡排序
选择排序
插入排序
>>>>>>> fbf0d81439a58342cdb77301705c99d4a989f1ab
=======
冒泡排序
选择排序
插入排序
>>>>>>> fbf0d81439a58342cdb77301705c99d4a989f1ab
Dijkstra算法
等...

##### 指数级
...

递归求解斐波那契数列

##### 阶乘级别
...

#### 空间复杂度

桶排序
=======
###### 读取元素

时间复杂度：$O(1)$

##### 对数级

<<<<<<< HEAD
=======
时间复杂度:  $O(log_2n)$

>>>>>>> 249f00bb253a0de8d477fd5f2b051fbd8d6d74f5
###### 二分查找

因为二分查找不会查找数列的全部元素，而查找的数据量其实正好符合元素的对数，正常情况下每次查找的元素都在一半一半地减少。

<<<<<<< HEAD
时间复杂度:  $O(log_2n)$

=======
>>>>>>> 249f00bb253a0de8d477fd5f2b051fbd8d6d74f5
在一个**有序**序列中查找某个数key:

```c++
int main(){
    int key;
    cin >> key;
    vector<int> v = {1, 4, 5, 6, 7, 9};
    int l = 0, r = v.size() - 1;
    int mid;
    while(l <= r){
        mid = (l + r) / 2;
        if(v[mid] == key){
            cout << "已找到" << endl;
            return 0;
        }
        else if(v[mid] < key)
            l = mid + 1;
        else
            r = mid - 1;
    }
    cout << "未找到" << endl;
    return 0;
}
```

##### 线性级

###### 查找元素

时间复杂度：$O(n)$

```c++
void print(vector<int> arr){
    for(int i = 0; i < arr.size(); i++)
        cout << arr[i] << endl;
}
```

##### 线性对数级

<<<<<<< HEAD
###### 快速排序：（可以趋近于幂级）

时间复杂度：$O(n log_2n)$

=======
时间复杂度：$O(n log_2n)$

###### 快速排序：（可以趋近于幂级）

>>>>>>> 249f00bb253a0de8d477fd5f2b051fbd8d6d74f5
1. 首先在一个序列中找一个数作为基准(key)，一般取第一个，遍历一次数组，使key左边的数均小于key，右边的数大于key；
2. 第一轮后以key为分界点拆分成两个序列，继续递归。

```c++
void quick_sort(vector<int> &nums, int l, int r) { //l = 0, r = nums.size()
    if (l + 1 >= r)
        return;
    int first = l, last = r - 1, key = nums[first]; //取第一个数为基准
    while (first < last){
        while(first < last && nums[last] >= key) {
            --last;
        }
        nums[first] = nums[last]; //找到小于key的数，放在左边
        while (first < last && nums[first] <= key) {
            ++first;
        }
        nums[last] = nums[first]; //大于key的数放右边
    }
    nums[first] = key;
    quick_sort(nums, l, first);
    quick_sort(nums, first + 1, r);
}
```

###### 归并排序

<<<<<<< HEAD
时间复杂度：$O(n log_2n)$

=======
>>>>>>> 249f00bb253a0de8d477fd5f2b051fbd8d6d74f5
1. 将序列中待排序数字分为若干组(每个数字为一组)；
2. 将若干个组两两合并，保证合并后的组使有序的；
3. 重复第二步直到只剩一组。

```c++
void merge_sort(vector<int> &nums, int l, int r, vector<int> &temp) {
    if (l + 1 >= r) {
        return;
    }// 递归结束条件，每个数字为单独的一组
    int m = l + (r - l) / 2;
    merge_sort(nums, l, m, temp);
    merge_sort(nums, m, r, temp);
    int p = l, q = m, i = l;
    while (p < m || q < r) {
        if (q >= r || (p < m && nums[p] <= nums[q])) {
            temp[i++] = nums[p++];
        } else {
            temp[i++] = nums[q++];
        }
    }
    for (i = l; i < r; ++i) {
        nums[i] = temp[i];
    }
}
```

##### 幂级

###### 冒泡排序

时间复杂度：$O(n^{2})$

```c++
void bubble_sort(vector<int> nums)
{
    int temp = 0, i = 0, j = 0;
    for (i = 0; i < nums.size() - 1; i++){
        for (j = 0; j < nums.size() - 1 - i; j++){
            if (nums[j] > nums[j + 1]){
                temp = nums[j];
                nums[j] = nums[j + 1];
                nums[j + 1] = temp;
            }
        }
    }
}
```

<<<<<<< HEAD
##### 指数级

###### 递归求解斐波那契数列
=======


##### 指数级

###### 递归求解斐波那契数列:
>>>>>>> 249f00bb253a0de8d477fd5f2b051fbd8d6d74f5

时间复杂度：$O(2^{n})$

```c++
int fib(int index) {
    // 设置结束递归的条件
    if (index == 1 || index == 2)
        return 1;
    return fib(index - 1) + fib(index - 2);
}
```
<<<<<<< HEAD

##### 阶乘级别

###### 旅行推销员问题
=======



##### 阶乘级别

###### 旅行推销员问题：
>>>>>>> 249f00bb253a0de8d477fd5f2b051fbd8d6d74f5

时间复杂度：$O(n!)$

问题描述: 设有$N$个城市组成的交通图，一个售货员从住地城市出发，到其他城市各次取推销货物，最后回到住地城市。假定任意两个城市$i$, $j$之间的距离$d$是已知的，问应该怎么样选择一条最短的路线。

<<<<<<< HEAD
#### 空间复杂度

##### 桶排序
=======


#### 空间复杂度

###### 桶排序
>>>>>>> 249f00bb253a0de8d477fd5f2b051fbd8d6d74f5

空间复杂度：$O(n)$

```c++
void bksort(vector<int> v){ // v中数均小于105
    int hash[105]
    for (int i = 0; i < v.size(); i++) {
        hash[v[i]]++;
    }
    for (int i = 0; i < 105; i++) {
        if (v[i] != 0) {
            for (int j = 1; j <= v[i]; j++) 
                cout << i << ' ';
        }
    }
    return 0;
}
```
<<<<<<< HEAD
=======



>>>>>>> 249f00bb253a0de8d477fd5f2b051fbd8d6d74f5
>>>>>>> Stashed changes

### 算法优化
算法优化是指对算法的有关性能进行优化，如时间复杂度、 空间复杂度 、正确性、健壮性。 大数据时代到来，算法要处理数据的数量级也越来越大以及处理问题的场景千变万化。 为了增强算法的处理问题的能力，对算法进行优化是必不可少的。
比如 当给到一个程序员幂级的算法时优秀的程序员通常会想到将其优化成对数级的算法
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD

=======
>>>>>>> fbf0d81439a58342cdb77301705c99d4a989f1ab
=======
>>>>>>> fbf0d81439a58342cdb77301705c99d4a989f1ab
=======
>>>>>>> fbf0d81439a58342cdb77301705c99d4a989f1ab
## 算法思想

### 有哪些算法思想？

枚举/朴素/暴力、模拟、分治和递归、贪心、动态规划、回溯、排序、查找、搜索

### 算法思想与现实生活的联系

## 算法中的数据结构